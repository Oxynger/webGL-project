<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>WebGL for fun </title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
	<canvas id="mainWindow" width=1000, height=500></canvas>
	<script id="3d-vertex-shader" type="x-shader/x-vertex">
		attribute vec4 a_position;
		attribute vec3 a_normal;

		uniform vec3 u_lightWorldPosition;
		uniform vec3 u_viewWorldPosition;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;
		
		varying vec3 v_normal;
		
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;
		
			vec3 surfaceWorldPosition = (u_worldInverseTranspose * a_position).xyz;
		
			v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;

			v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;
		}
           
	</script>

	<script id="3d-fragment-shader" type="notjs">
		precision mediump float;

		// Passed in from the vertex shader.
		varying vec3 v_normal;
		varying vec3 v_surfaceToLight;
		varying vec3 v_surfaceToView;

		uniform vec4 u_color;
		uniform float u_shininess;
		uniform vec3 u_lightColor;
		uniform vec3 u_specularColor;
		uniform vec3 u_lightDirection;
		uniform float u_limit;

		void main() {
			// because v_normal is a varying it's interpolated
			// we it will not be a uint vector. Normalizing it
			// will make it a unit vector again
			vec3 normal = normalize(v_normal);

			vec3 surfaceToLightDirection = normalize(v_surfaceToLight);
			vec3 surfaceToViewDirection = normalize(v_surfaceToView);
			vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);
			
			float light = 0.0;
			float specular = 0.0;

			float dotFromDirection = dot(surfaceToLightDirection, -u_lightDirection);

			if (dotFromDirection >= u_limit) {
				light = dot(normal, surfaceToLightDirection);
				if (light > 0.0) {
				  specular = pow(dot(normal, halfVector), u_shininess);
				}
			}
			
			gl_FragColor = u_color;

			// Lets multiply just the color portion (not the alpha)
			// by the light
			gl_FragColor.rgb *= light * u_lightColor;

			// Add Glare 
			gl_FragColor.rgb += specular * u_specularColor;
		}
				   
	</script>
	<script src="js/webgl-utils.js"></script>
	<script src="js/figureGeometry.js"></script>
	<script src="js/m4.js"></script>
	<script src="js/webgl-debug.js"></script>
	<script src="js/main.js "></script>

</body>

</html>