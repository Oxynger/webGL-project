<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>WebGL for fun </title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
	<canvas id="mainWindow" width=1000, height=500></canvas>
	<script id="3d-vertex-shader" type="x-shader/x-vertex">
		attribute vec4 a_position;
		attribute vec3 a_normal;

		uniform vec3 u_lightWorldPosition;

		uniform mat4 u_world;
		uniform mat4 u_worldViewProjection;
		uniform mat4 u_worldInverseTranspose;
		
		varying vec3 v_normal;
		
		varying vec3 v_surfaceToLight;

		void main() {
			// Multiply the position by the matrix.
			gl_Position = u_worldViewProjection * a_position;

			// orient the normals and pass to the fragment shader
			v_normal = mat3(u_worldInverseTranspose) * a_normal;
		
			vec3 surfaceWorldPosition = (u_worldInverseTranspose * a_position).xyz;
		
			v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;
		}
           
	</script>

	<script id="3d-fragment-shader" type="notjs">
		precision mediump float;

		// Passed in from the vertex shader.
		varying vec3 v_normal;
		varying vec3 v_surfaceToLight;

		uniform vec4 u_color;
		
		void main() {
			// because v_normal is a varying it's interpolated
			// we it will not be a uint vector. Normalizing it
			// will make it a unit vector again
			vec3 normal = normalize(v_normal);

			vec3 surfaceToLightDirection = normalize(v_surfaceToLight);

			float light = dot(normal, surfaceToLightDirection);

			gl_FragColor = u_color;

			// Lets multiply just the color portion (not the alpha)
			// by the light
			gl_FragColor.rgb *= light;
		}
				   
	</script>
	<script src="js/webgl-utils.js"></script>
	<script src="js/figureGeometry.js"></script>
	<script src="js/m4.js"></script>
	<script src="js/webgl-debug.js"></script>
	<script src="js/main.js "></script>

</body>

</html>